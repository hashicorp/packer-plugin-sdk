// snippet-extract --begin=#_BEGIN_WRAP_TAG_ --end=#_END_WRAP_TAG_ -output_dir=./docs/ [./file|./directory/]...
// Extracts markdown snippets from relative files into output_dir, keeping the
// directory layout.
// It is not mandatory to terminate a snippet, the extractor will simply add
// line until EOF.
// Lines matching begin or end tags will not be put in the resulting file.
// When a directory is passed, all files from directory will be parsed.
package snippet_extractor

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/mitchellh/cli"
)

type SnippetExtractorCMD struct {
	Ui         cli.Ui
	Filenames  []string
	Begin, End string
	OutputDir  string
	Extension  string
}

func (cmd *SnippetExtractorCMD) Help() string {
	return `
	Usage: snippet-extract --begin=#_BEGIN_WRAP_TAG_ --end=#_END_WRAP_TAG_ -output_dir=./docs/ [file|directory/]
	`
}

func (cmd *SnippetExtractorCMD) Synopsis() string {
	return "CHANGE ME"
}

func (cmd *SnippetExtractorCMD) Flags() *flag.FlagSet {
	fs := flag.NewFlagSet("snippet-extractor", flag.ExitOnError)
	fs.StringVar(&cmd.Begin, "begin", "#_BEGIN_WRAP_TAG_", "flag to mark beginning of a snippet")
	fs.StringVar(&cmd.End, "end", "#_END_WRAP_TAG_", "flag to mark ending of a snippet")
	fs.StringVar(&cmd.OutputDir, "output_dir", "./docs/", "directory in which the files will be generated, note that the directory layout is kept")
	fs.StringVar(&cmd.Extension, "extension", ".mdx", "extension for generated files")
	return fs
}

func (cmd *SnippetExtractorCMD) Run(args []string) int {
	if len(args) == 0 {
		cmd.Ui.Info(cmd.Help())
		return 1
	}

	fs := cmd.Flags()
	err := fs.Parse(args)
	if err != nil {
		cmd.Ui.Error(fmt.Sprintf("unable to parse flags: %s", err))
		return 1
	}

	wd, _ := os.Getwd()
	fmt.Printf("working from %s\n", wd)
	cmd.Filenames = extractFilenames(fs.Args())
	for _, filename := range cmd.Filenames {
		cmd.Ui.Info("processing " + filename)
		ext := filepath.Ext(filename)
		snippets, err := extractSnippets(cmd.Begin, cmd.End, filename)
		if err != nil {
			cmd.Ui.Error(fmt.Sprintf("could not open file: %s", err))
			return 1
		}

		for _, snippet := range snippets {
			outputFile := filepath.Join(cmd.OutputDir, filepath.Base(filename), snippet.Identifier+cmd.Extension)
			fmt.Println("File saved to" + outputFile)
			folder := filepath.Dir(outputFile)
			err := os.MkdirAll(folder, os.ModePerm)
			if err != nil {
				cmd.Ui.Error(fmt.Sprintf("cannot mkdir %s: %s", folder, err))
			}
			f := bytes.NewBuffer(nil)
			fmt.Fprintf(f, `<!-- Code generated by snippet-extractor %s; DO NOT EDIT MANUALLY -->`, strings.Join(args[1:], " "))
			fmt.Fprintf(f, "\n\n```%s\n%s```\n", ext, snippet.Text)
			err = ioutil.WriteFile(outputFile, f.Bytes(), 0600)
			if err != nil {
				cmd.Ui.Error(fmt.Sprintf("cannot write %s in %s: %s", filepath.Base(outputFile), folder, err))
			}
		}
	}

	return 0
}

type snippet struct {
	Identifier string
	Text       string
	Closed     bool
}

func extractSnippets(beginPattern, endPattern, filename string) ([]snippet, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("could not open file: %s", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)

	snippets := []snippet{}
	for scanner.Scan() {
		line := scanner.Text()
		if identifier := matches(line, beginPattern); identifier != "" {
			snippets = append(snippets, snippet{
				Identifier: identifier,
			})
			continue
		}
		if identifier := matches(line, endPattern); identifier != "" {
			for i := range snippets {
				snippet := &snippets[i]
				if snippet.Identifier == identifier {
					snippet.Closed = true
				}
			}
			continue
		}
		for i := range snippets {
			snippet := &snippets[i]
			if snippet.Closed {
				continue
			}
			snippet.Text = snippet.Text + line + "\n"
		}
	}
	return snippets, nil
}

func matches(s, prefix string) string {
	trimmed := strings.TrimSpace(s)
	lenDiff := len(s) - len(trimmed)
	if strings.HasPrefix(trimmed, prefix) {
		return s[len(prefix)+lenDiff:]
	}
	return ""
}

// if an entry is a directory all files from directory will be listed.
func extractFilenames(in []string) []string {
	out := []string{}
	for _, path := range in {
		fi, err := os.Stat(path)
		if err != nil {
			log.Fatalf("%s: %s", path, err)
		}
		if !fi.IsDir() {
			out = append(out, path)
			continue
		}
		files, err := ioutil.ReadDir(path)
		if err != nil {
			log.Fatalf("could not read directory %s: %s", path, err)
		}
		for _, file := range files {
			if file.IsDir() {
				continue
			}
			out = append(out, file.Name())
		}
	}
	return out
}
